var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { validatePackage } from '@progress/kendo-licensing';
import { packageMetadata } from './package-metadata';
import { classNames, useDraggable, clone, noop } from '@progress/kendo-react-common';
import { TaskBoardColumnBase } from './TaskBoardColumnBase';
import { TaskBoardCardBase } from './TaskBoardCardBase';
import { TASKBOARD_COLUMN, TASKBOARD_PLACEHOLDER, TASKBOARD_TASK } from './constants';
import { closestTaskBoardElement, findIndexes } from './utils';
import { TaskBoardCard } from './card/Card';
import { TaskBoardColumn } from './column/Column';
/**
 * Represents the [KendoReact TaskBoard component]({% slug overview_taskboard %}).
 *
 * Accepts properties of type [TaskBoardProps]({% slug api_taskboard_taskboardprops %}).
 */
export var TaskBoard = React.forwardRef(function (props, ref) {
    validatePackage(packageMetadata);
    var columnData = props.columnData, className = props.className, style = props.style, id = props.id, taskData = props.taskData, onChange = props.onChange;
    var taskboardRef = React.useRef(null);
    var taskboardElementRef = React.useRef(null);
    React.useImperativeHandle(taskboardRef, function () {
        return { props: props };
    });
    React.useImperativeHandle(ref, function () { return taskboardRef.current; });
    var children = React.Children.toArray(props.children);
    var toolbar = children.filter(function (child) { return child && child.type &&
        child.type.displayName === 'KendoReactTaskBoardToolbar'; });
    var elementRef = React.useRef(null);
    var dragTargetRef = React.useRef(null);
    var pressOffsetRef = React.useRef(null);
    var _a = React.useState(null), taskDataState = _a[0], setTaskDataState = _a[1];
    var _b = React.useState(null), columnDataState = _b[0], setColumnDataState = _b[1];
    var _c = React.useState({ top: 0, left: 0 }), position = _c[0], setPosition = _c[1];
    var dragCardCueRef = React.useRef(null);
    var dragColumnCueRef = React.useRef(null);
    var tasksMap = React.useMemo(function () {
        var map = {};
        (taskDataState || taskData).forEach(function (task) {
            var currentStatus = task.status;
            if (!map[currentStatus]) {
                map[currentStatus] = [];
            }
            map[currentStatus].push(task);
        });
        return map;
    }, [taskData, taskDataState]);
    var handlePress = React.useCallback(function (event) {
        var target = event.originalEvent.target;
        if (target.closest('button,input,.k-link,.k-taskboard-preview-pane')) {
            return;
        }
        var currentDragTarget = closestTaskBoardElement(target);
        var taskboardEl = taskboardElementRef.current;
        if (currentDragTarget && taskboardEl) {
            var isColumn = currentDragTarget.type === TASKBOARD_COLUMN;
            if (isColumn && !target.closest('.k-taskboard-column-header')) {
                return;
            }
            var dragElement = currentDragTarget.element;
            var rect = dragElement.getBoundingClientRect();
            var parentRect = taskboardEl.getBoundingClientRect();
            pressOffsetRef.current = {
                x: event.clientX - rect.left + parentRect.left,
                y: event.clientY - rect.top + parentRect.top
            };
            var data = isColumn ? columnData : taskData;
            var stateSetter = isColumn ? setColumnDataState : setTaskDataState;
            var index = data.findIndex(function (dataItem) { return String(dataItem.id) === currentDragTarget.id; });
            var item = data[index];
            if (index === -1 || item.edit) {
                return;
            }
            var newItem = clone(item);
            newItem.isPlaceholder = true;
            var newData = __spreadArray([], data, true);
            newData[index] = newItem;
            dragTargetRef.current = __assign(__assign({}, currentDragTarget), { index: index, item: item, width: rect.width, height: rect.height });
            setPosition({
                top: event.clientY - pressOffsetRef.current.y,
                left: event.clientX - pressOffsetRef.current.x
            });
            stateSetter(newData);
        }
    }, [columnData, taskData]);
    var handleDrag = React.useCallback(function (event) {
        var currentDragTarget = dragTargetRef.current;
        var dragCueElement = (dragCardCueRef.current && dragCardCueRef.current.element) || dragColumnCueRef.current;
        if (currentDragTarget && dragCueElement) {
            setPosition({
                top: event.clientY - pressOffsetRef.current.y,
                left: event.clientX - pressOffsetRef.current.x
            });
            dragCueElement.style.visibility = 'hidden';
            var targetElement = document.elementFromPoint(event.clientX, event.clientY);
            dragCueElement.style.visibility = '';
            if (targetElement && targetElement.getAttribute(TASKBOARD_PLACEHOLDER)) {
                return;
            }
            var dropTarget_1 = targetElement && closestTaskBoardElement(targetElement);
            if (dropTarget_1) {
                var indexes = void 0;
                var isSameType = dropTarget_1.type === currentDragTarget.type;
                var isDragTargetColumn = currentDragTarget.type === TASKBOARD_COLUMN;
                var data = (isDragTargetColumn ? columnDataState : taskDataState) || [];
                var stateSetter = isDragTargetColumn ? setColumnDataState : setTaskDataState;
                if (isDragTargetColumn || isSameType) {
                    indexes = findIndexes(currentDragTarget.id, dropTarget_1.id, data);
                    if (indexes) {
                        var dragItem = data[indexes.dragIndex];
                        var dropItem = data[indexes.dropIndex];
                        var newDragItem = clone(dragItem);
                        if (!isDragTargetColumn) {
                            newDragItem.status = dropItem.status;
                        }
                        var newData = __spreadArray([], data, true);
                        newData.splice(indexes.dragIndex, 1);
                        newData.splice(indexes.dropIndex, 0, newDragItem);
                        currentDragTarget.index = indexes.dropIndex;
                        stateSetter(newData);
                    }
                }
                else {
                    var taskIndex = data.findIndex(function (item) { return String(item.id) === currentDragTarget.id; });
                    var columnIndex = columnData.findIndex(function (item) { return String(item.id) === dropTarget_1.id; });
                    if (taskIndex !== -1 && columnIndex !== -1) {
                        var task = data[taskIndex];
                        var column = columnData[columnIndex];
                        var columnStatus = column.status;
                        if (tasksMap[columnStatus]) {
                            return;
                        }
                        task.status = columnStatus;
                        var newData = __spreadArray([], data, true);
                        newData.splice(taskIndex, 1);
                        newData.push(task);
                        currentDragTarget.index = newData.length - 1;
                        stateSetter(newData);
                    }
                }
            }
        }
    }, [columnDataState, taskDataState, columnData, tasksMap]);
    var handleRelease = React.useCallback(function () {
        var currentDragTarget = dragTargetRef.current;
        if (onChange && currentDragTarget) {
            var isDragTargetColumn = currentDragTarget.type === TASKBOARD_COLUMN;
            var data = (isDragTargetColumn ? columnDataState : taskDataState) || [];
            var item = data[currentDragTarget.index];
            delete item.isPlaceholder;
            var event_1 = {
                data: data,
                type: currentDragTarget.type,
                previousItem: currentDragTarget.item,
                item: item
            };
            onChange.call(undefined, event_1);
        }
        dragTargetRef.current = null;
        pressOffsetRef.current = null;
        setTaskDataState(null);
        setColumnDataState(null);
        setPosition({ top: 0, left: 0 });
    }, [columnDataState, taskDataState, onChange]);
    useDraggable(elementRef, {
        onDragStart: handlePress,
        onDrag: handleDrag,
        onDragEnd: handleRelease
    });
    var dragTarget = dragTargetRef.current;
    var onTaskCreate = React.useCallback(function (newTask) {
        var tasks = __spreadArray(__spreadArray([], taskData, true), [newTask], false);
        var event = {
            data: tasks,
            type: TASKBOARD_TASK,
            previousItem: null,
            item: newTask
        };
        onChange.call(undefined, event);
    }, [onChange, taskData]);
    var onTaskEdit = React.useCallback(function (task, prevTask) {
        var tasks = taskData.slice();
        var index = taskData.indexOf(prevTask);
        if (index !== -1) {
            tasks.splice(index, 1, task);
        }
        var event = {
            data: tasks,
            type: TASKBOARD_TASK,
            previousItem: prevTask,
            item: task
        };
        onChange.call(undefined, event);
    }, [onChange, taskData]);
    var onTaskDelete = React.useCallback(function (task) {
        var tasks = taskData.filter(function (t) { return t !== task; });
        var event = {
            data: tasks,
            type: TASKBOARD_TASK,
            previousItem: task,
            item: null
        };
        onChange.call(undefined, event);
    }, [onChange, taskData]);
    var onColumnChange = React.useCallback(function (newColumn, prevColumn) {
        var data = columnData.slice();
        var index = data.indexOf(prevColumn);
        if (index !== -1) {
            if (newColumn) {
                data.splice(index, 1, newColumn);
            }
            else {
                data.splice(index, 1);
            }
        }
        var event = {
            data: data,
            type: TASKBOARD_COLUMN,
            previousItem: prevColumn,
            item: newColumn
        };
        onChange.call(undefined, event);
    }, [onChange, columnData]);
    return (React.createElement("div", { id: id, style: style, ref: taskboardElementRef, className: classNames('k-widget k-taskboard', className) },
        toolbar,
        React.createElement("div", { className: 'k-taskboard-content', style: dragTarget ? { userSelect: 'none' } : undefined },
            React.createElement("div", { className: 'k-taskboard-columns-container', ref: elementRef }, (columnDataState || columnData).map(function (column) { return (React.createElement(TaskBoardColumnBase, { key: column.id, tabIndex: props.tabIndex, column: column, tasks: tasksMap[column.status] || [], dragTargetRef: dragTargetRef, onTaskCreate: onTaskCreate, onTaskEdit: onTaskEdit, onTaskDelete: onTaskDelete, onColumnChange: onColumnChange, columnComponent: props.column || TaskBoardColumn, cardComponent: props.card || TaskBoardCard, priorities: props.priorities })); }))),
        dragTarget && dragTarget.type === TASKBOARD_TASK && (React.createElement(TaskBoardCardBase, { elementRef: dragCardCueRef, style: {
                position: 'absolute',
                width: dragTarget.width,
                height: dragTarget.height,
                top: position.top,
                left: position.left,
                zIndex: 10,
                borderLeftColor: dragTarget.item.priority ? dragTarget.item.priority.color : dragTarget.item.color
            }, task: dragTarget.item, dragTargetRef: dragTargetRef, cardComponent: props.card || TaskBoardCard, onDeleteTask: noop, showEditPane: noop })),
        dragTarget && dragTarget.type === TASKBOARD_COLUMN && (React.createElement(TaskBoardColumnBase, { elementRef: dragColumnCueRef, style: {
                position: 'absolute',
                width: dragTarget.width,
                height: dragTarget.height,
                top: position.top,
                left: position.left,
                zIndex: 10
            }, cardComponent: props.card || TaskBoardCard, columnComponent: props.column || TaskBoardColumn, column: dragTarget.item, tasks: tasksMap[dragTarget.item.status], priorities: props.priorities, dragTargetRef: dragTargetRef, onTaskDelete: onTaskDelete, onColumnChange: onColumnChange, onTaskEdit: onTaskEdit, onTaskCreate: onTaskCreate }))));
});
var defaultProps = {
    columnData: [],
    taskData: []
};
TaskBoard.propTypes = {
    columnData: PropTypes.array.isRequired,
    taskData: PropTypes.array.isRequired
};
TaskBoard.defaultProps = defaultProps;
TaskBoard.displayName = 'KendoReactTaskBoard';
