"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Map = void 0;
var React = require("react");
var PropTypes = require("prop-types");
var kendo_charts_1 = require("@progress/kendo-charts");
var map_event_builder_1 = require("./events/map-event-builder");
var store_1 = require("./store/store");
var reducer_1 = require("./store/reducer");
require("./defaults");
var MapContext_1 = require("./MapContext");
var MapTooltip_1 = require("./tooltip/MapTooltip");
var kendo_react_common_1 = require("@progress/kendo-react-common");
var package_metadata_1 = require("./package-metadata");
var dom_event_1 = require("./events/dom-event");
var kendo_svg_icons_1 = require("@progress/kendo-svg-icons");
var svgIcons = {
    mapMarkerTargetIcon: kendo_svg_icons_1.mapMarkerTargetIcon,
    mapMarkerIcon: kendo_svg_icons_1.mapMarkerIcon,
    plusIcon: kendo_svg_icons_1.plusIcon,
    minusIcon: kendo_svg_icons_1.minusIcon,
    caretAltUpIcon: kendo_svg_icons_1.caretAltUpIcon,
    caretAltDownIcon: kendo_svg_icons_1.caretAltDownIcon,
    caretAltLeftIcon: kendo_svg_icons_1.caretAltLeftIcon,
    caretAltRightIcon: kendo_svg_icons_1.caretAltRightIcon
};
var defaultIconsType = 'svg';
/**
 * Represents the [KendoReact Map component]({% slug overview_map %}).
 */
var Map = /** @class */ (function (_super) {
    __extends(Map, _super);
    function Map(props) {
        var _this = _super.call(this, props) || this;
        /**
         * @hidden
         */
        _this.mapInstance = null;
        _this._element = null;
        _this.optionsStore = {};
        _this.optionsUnsubscriber = Function.prototype;
        _this.observersStore = {};
        _this.iconsType = defaultIconsType;
        _this.svgIcons = svgIcons;
        /* Map handlers */
        /**
         * @hidden
         */
        _this.onInit = function (e) {
            _this.mapInstance = e.sender;
        };
        /**
         * @hidden
         */
        _this.onRender = function (e) {
            if (_this.mapInstance !== null) {
                _this.trigger('render', e);
            }
        };
        /* Dom event handlers */
        /**
         * @hidden
         */
        _this.onMapMouseLeave = function (e) {
            var domEvent = (0, dom_event_1.toDomEvent)(_this, e);
            var isDefaultPrevented = _this.triggerDomEvent('onMouseLeave', domEvent);
            if (isDefaultPrevented) {
                e.preventDefault();
            }
            else if (_this.mapInstance !== null) {
                _this.mapInstance.hideTooltip();
            }
        };
        (0, kendo_react_common_1.validatePackage)(package_metadata_1.packageMetadata);
        _this.optionsStore = (0, store_1.default)(reducer_1.optionsReducer);
        _this.observersStore = (0, store_1.default)(reducer_1.observersReducer);
        _this.childrenObserver = new kendo_charts_1.InstanceObserver(_this, { onMouseLeave: 'onChildMouseLeave' });
        _this.contextValue = {
            optionsStore: _this.optionsStore,
            observersStore: _this.observersStore,
            childrenObserver: _this.childrenObserver
        };
        _this.mapObserver = new kendo_charts_1.InstanceObserver(_this, {
            // render: 'onRender',
            init: 'onInit'
        });
        return _this;
    }
    Object.defineProperty(Map.prototype, "element", {
        /**
         * @hidden
         */
        get: function () {
            return this._element;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @hidden
     */
    Map.prototype.componentDidMount = function () {
        this.instantiateCoreMap();
        this.optionsUnsubscriber = this.optionsStore.subscribe(this.refresh.bind(this));
    };
    /**
     * @hidden
     */
    Map.prototype.componentWillUnmount = function () {
        this.optionsUnsubscriber();
        if (this.mapInstance !== null) {
            this.mapInstance.destroy();
            this.mapInstance = null;
        }
    };
    /**
     * @hidden
     */
    Map.prototype.componentDidUpdate = function (prevProps) {
        var _a = this.props, dir = _a.dir, children = _a.children, spreadProps = __rest(_a, ["dir", "children"]);
        if (this.mapInstance !== null) {
            var shouldUpdate = Object.entries(prevProps)
                .filter(function (keyValue) { return (keyValue[0] !== 'dir' && keyValue[0] !== 'children'); })
                .some(function (keyValue) {
                var key = keyValue[0], value = keyValue[1];
                return !(spreadProps.hasOwnProperty(key) && spreadProps[key] === value);
            });
            if (shouldUpdate) {
                this.refresh();
            }
            if (prevProps.dir !== dir) {
                // TODO: Set k-rtl instead
                // this.mapInstance.setDirection(this.getDirection(dir));
            }
        }
    };
    /**
     * @hidden
     */
    Map.prototype.render = function () {
        var _this = this;
        var _a = this.props, _b = _a.style, style = _b === void 0 ? {} : _b, className = _a.className, children = _a.children;
        var mapStyles = Object.assign({}, style, { position: 'relative' });
        var content = React.createElement('div', {
            className: className,
            style: mapStyles,
            key: 'mapElement'
        }, (React.createElement("div", { ref: function (el) { return _this._element = el; }, className: "k-map", onMouseLeave: this.onMapMouseLeave }, children)));
        return (React.createElement(kendo_react_common_1.IconsContext.Consumer, null, function (value) { return (React.createElement(MapContext_1.MapContext.Provider, { value: _this.contextValue },
            React.createElement(MapTooltip_1.MapTooltip, { key: "tooltip" }),
            content,
            _this.setIcons(value))); }));
    };
    /**
     * @hidden
     */
    Map.prototype.getMapOptions = function () {
        var _a = this.props, center = _a.center, controls = _a.controls, minZoom = _a.minZoom, maxZoom = _a.maxZoom, minSize = _a.minSize, pannable = _a.pannable, wraparound = _a.wraparound, zoom = _a.zoom, zoomable = _a.zoomable;
        var mapOptions = {
            center: center,
            controls: controls,
            minZoom: minZoom,
            maxZoom: maxZoom,
            minSize: minSize,
            pannable: pannable,
            wraparound: wraparound,
            zoom: zoom,
            zoomable: zoomable,
            icons: {
                type: this.iconsType,
                svgIcons: this.svgIcons
            }
        };
        mapOptions = Object.assign(mapOptions, this.optionsStore.getState());
        return mapOptions;
    };
    Object.defineProperty(Map.prototype, "layers", {
        /**
         * The marker layers instances.
         */
        get: function () {
            var _a;
            return (_a = this.mapInstance) === null || _a === void 0 ? void 0 : _a.layers;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Map.prototype, "extent", {
        /**
         * Gets the extent (visible area) of the map.
         */
        get: function () {
            var _a;
            return (_a = this.mapInstance) === null || _a === void 0 ? void 0 : _a.extent();
        },
        /**
         * Sets the extent (visible area) of the map.
         */
        set: function (extent) {
            var _a;
            (_a = this.mapInstance) === null || _a === void 0 ? void 0 : _a.extent(extent);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Detects the size of the container and redraws the Map.
     * Resizing is automatic unless you set the `resizeRateLimit` option to `0`.
     */
    Map.prototype.resize = function () {
        // this.mapInstance?.resize();
    };
    /**
     * Retrieves the size of the visible portion of the map.
     *
     * @returns The size (width and height) of the visible portion of the map.
     */
    Map.prototype.viewSize = function () {
        var _a;
        return (_a = this.mapInstance) === null || _a === void 0 ? void 0 : _a.viewSize();
    };
    /**
     * Returns the event coordinates relative to the map element. Offset coordinates are not synchronized to a particular location on the map.
     *
     * @param e The mouse event.
     * @returns The event coordinates relative to the map element.
     */
    Map.prototype.eventOffset = function (e) {
        var _a;
        return (_a = this.mapInstance) === null || _a === void 0 ? void 0 : _a.eventOffset(e);
    };
    /**
     * Retrieves projected (layer) coordinates that correspond to this mouse event.
     * Layer coordinates are absolute and change only when the zoom level is changed.
     *
     * @param e The mouse event.
     * @returns The projected (layer) coordinates that correspond to this event.
     */
    Map.prototype.eventToLayer = function (e) {
        var _a;
        return (_a = this.mapInstance) === null || _a === void 0 ? void 0 : _a.eventToLayer(e);
    };
    /**
     * Retrieves the geographic location that correspond to this mouse event.
     *
     * @param e The mouse event.
     * @returns The geographic location that correspond to this mouse event.
     */
    Map.prototype.eventToLocation = function (e) {
        var _a;
        return (_a = this.mapInstance) === null || _a === void 0 ? void 0 : _a.eventToLocation(e);
    };
    /**
     * Retrieves relative (view) coordinates that correspond to this mouse event.
     * Layer elements positioned on these coordinates will appear under the mouse cursor.
     * View coordinates are no longer valid after a map reset.
     *
     * @param e The mouse event.
     * @returns The relative (view) coordinates that correspond to this mouse event.
     */
    Map.prototype.eventToView = function (e) {
        var _a;
        return (_a = this.mapInstance) === null || _a === void 0 ? void 0 : _a.eventToView(e);
    };
    /**
     * Transforms layer (projected) coordinates to geographical location.
     *
     * @param point The layer (projected) coordinates. An array argument is assumed to be in x, y order.
     * @param zoom Optional. Assumed zoom level. Defaults to the current zoom level.
     * @returns The geographic location that corresponds to the layer coordinates.
     */
    Map.prototype.layerToLocation = function (point, zoom) {
        var _a;
        return (_a = this.mapInstance) === null || _a === void 0 ? void 0 : _a.layerToLocation(point, zoom);
    };
    /**
     * Returns the layer (projected) coordinates that correspond to a geographical location.
     *
     * @param location The geographic location. An array argument is assumed to be in [Latitude, Longitude] order.
     * @param zoom Optional. Assumed zoom level. Defaults to the current zoom level.
     * @returns The layer (projected) coordinates.
     */
    Map.prototype.locationToLayer = function (location, zoom) {
        var _a;
        return (_a = this.mapInstance) === null || _a === void 0 ? void 0 : _a.locationToLayer(location, zoom);
    };
    /**
     * Returns the view (relative) coordinates that correspond to a geographical location.
     *
     * @param location The geographic location. An array argument is assumed to be in [Latitude, Longitude] order.
     * @returns The view coordinates that correspond to a geographical location.
     */
    Map.prototype.locationToView = function (location) {
        var _a;
        return (_a = this.mapInstance) === null || _a === void 0 ? void 0 : _a.locationToView(location);
    };
    /**
     * Returns the geographical location that correspond to the view (relative) coordinates.
     *
     * @param point The view coordinates. An array argument is assumed to be in x, y order.
     * @param zoom Optional. Assumed zoom level. Defaults to the current zoom level.
     * @returns The geographic location that corresponds to the view coordinates.
     */
    Map.prototype.viewToLocation = function (point, zoom) {
        var _a;
        return (_a = this.mapInstance) === null || _a === void 0 ? void 0 : _a.viewToLocation(point, zoom);
    };
    /**
     * Load markers in the Map. This method will clear the current markers and show the new ones.
     *
     * @param newMarkers An array of markers.
     */
    Map.prototype.loadMarkers = function (newMarkers) {
        var markers = this.mapInstance.markers;
        if (markers) {
            markers._load(newMarkers);
        }
    };
    /**
     * @hidden
     */
    Map.prototype.refresh = function () {
        if (this.mapInstance !== null) {
            var mapOptions = this.getMapOptions();
            if (this.props.onRefresh) {
                this.props.onRefresh.call(undefined, mapOptions, this.mapInstance);
            }
            else {
                this.mapInstance.setOptions(mapOptions);
            }
        }
    };
    /**
     * @hidden
     */
    Map.prototype.instantiateCoreMap = function () {
        // const { dir } = this.props;
        var mapOptions = this.getMapOptions();
        this.mapInstance = new kendo_charts_1.Map(this.element, mapOptions, {}, {
            // rtl: this.getDirection(dir),
            observer: this.mapObserver,
            sender: this
        });
    };
    /* Triggers public dom event handlers */
    /**
     * @hidden
     */
    Map.prototype.trigger = function (name, e) {
        var alias = name === 'click' ? 'mapClick' : name;
        var target = this;
        var eventObject = (0, map_event_builder_1.create)(alias, e, target);
        var handler = 'on' + alias.charAt(0).toUpperCase() + alias.slice(1);
        var observers = this.observersStore.getState();
        var isDefaultPrevented = false;
        for (var idx = 0; idx < observers.length; idx++) {
            if (observers[idx].trigger(alias, e)) {
                isDefaultPrevented = true;
            }
        }
        /* We have not prevented the event internally, now pass it to the user */
        if (isDefaultPrevented === false
            && eventObject
            && this.props.hasOwnProperty(handler)) {
            this.props[handler].call(undefined, eventObject);
            return eventObject.isDefaultPrevented && eventObject.isDefaultPrevented();
        }
        return isDefaultPrevented;
    };
    /* Used by (event)InstanceObserver to check the wrapper for supported events */
    /**
     * @hidden
     */
    Map.prototype.requiresHandlers = function (names) {
        for (var idx = 0; idx < names.length; idx++) {
            var name_1 = names[idx];
            var handler = 'on' + name_1.charAt(0).toUpperCase() + name_1.slice(1);
            if (this.props.hasOwnProperty(handler)) {
                return true;
            }
        }
        return false;
    };
    /**
     * @hidden
     */
    Map.prototype.triggerDomEvent = function (name, e) {
        var observers = this.observersStore.getState();
        var isDefaultPrevented = false;
        for (var idx = 0; idx < observers.length; idx++) {
            if (observers[idx].trigger(name, e)) {
                isDefaultPrevented = true;
            }
        }
        return isDefaultPrevented;
    };
    Map.prototype.setIcons = function (iconsContextValue) {
        var type = iconsContextValue.type, _a = iconsContextValue.icons, icons = _a === void 0 ? {} : _a;
        var svgIconsResult = __assign({}, svgIcons);
        var overrides = {
            mapMarkerTargetIcon: icons.mapMarkerTargetIcon,
            mapMarkerIcon: icons.mapMarkerIcon,
            plusIcon: icons.plusIcon,
            minusIcon: icons.minusIcon,
            caretAltUpIcon: icons.caretAltUpIcon,
            caretAltDownIcon: icons.caretAltDownIcon,
            caretAltLeftIcon: icons.caretAltLeftIcon,
            caretAltRightIcon: icons.caretAltRightIcon
        };
        var key;
        for (key in overrides) {
            if (overrides[key]) {
                var icon = overrides[key];
                if (icon && typeof icon !== 'string') {
                    svgIconsResult[key] = icon;
                }
            }
        }
        this.svgIcons = svgIconsResult;
        this.iconsType = type || defaultIconsType;
        return null;
    };
    /**
     * @hidden
     */
    Map.propTypes = {
        dir: PropTypes.string
    };
    /**
     * @hidden
     */
    Map.defaultProps = {};
    return Map;
}(React.Component));
exports.Map = Map;
